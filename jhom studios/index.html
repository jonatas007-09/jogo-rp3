<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Mini City BR — Multiplayer + Chat + Smooth</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b0f14;font-family:system-ui,Segoe UI,Roboto,Arial}
    canvas{display:block}
    #hud{position:fixed;inset:0;pointer-events:none;color:#eaf1ff;text-shadow:0 1px 2px rgba(0,0,0,.6)}
    #topbar{
      position:absolute;left:12px;top:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;border-radius:12px;backdrop-filter: blur(8px);pointer-events:auto;
      max-width:min(1120px, calc(100vw - 24px));
    }
    #topbar button{
      pointer-events:auto;border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);color:#eaf1ff;border-radius:10px;padding:8px 10px;cursor:pointer;
    }
    #topbar button:hover{background:rgba(255,255,255,.14)}
    #topbar input{
      pointer-events:auto;border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);color:#eaf1ff;border-radius:10px;padding:8px 10px;outline:none;
    }
    #help{
      position:absolute;left:12px;bottom:12px;max-width:860px;
      background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;border-radius:12px;backdrop-filter: blur(8px);
      pointer-events:auto;line-height:1.35;
    }
    #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;opacity:.9}
    #crosshair:before,#crosshair:after{content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,.9);border-radius:2px}
    #crosshair:before{width:2px;height:18px}
    #crosshair:after{width:18px;height:2px}
    #stats{
      position:absolute;right:12px;top:12px;min-width:260px;
      background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;border-radius:12px;backdrop-filter: blur(8px);
      pointer-events:none;font-variant-numeric:tabular-nums;
    }
    .muted{opacity:.85}
    .kbd{display:inline-block;padding:1px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08)}
    .badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08)}
  </style>
</head>
<body>
<div id="hud">
  <div id="topbar">
    <button id="btnPlay">Entrar (Mouse Lock)</button>
    <button id="btnReset">Reset</button>
    <button id="btnQuality">Qualidade: Alta</button>

    <span class="badge">Multiplayer</span>
    <input id="mpName" placeholder="Seu nome" maxlength="18" style="width:130px"/>
    <input id="mpRoom" placeholder="Sala (ex: favela1)" maxlength="16" style="width:130px"/>
    <button id="btnJoin">Entrar na Sala</button>
    <span id="mpStatus" class="muted">offline</span>
  </div>

  <div id="stats"></div>
  <div id="crosshair"></div>

  <div id="help">
    <div><b>Mini City BR</b> <span class="muted">— multiplayer por sala + chat + players suaves (LERP)</span></div>
    <div style="margin-top:6px">
      <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> andar ·
      <span class="kbd">Shift</span> correr ·
      <span class="kbd">Espaço</span> pular ·
      <span class="kbd">Esc</span> solta o mouse ·
      <span class="kbd">T</span> chat
    </div>
    <div class="muted" style="margin-top:6px">
      Pra jogar com amigos: todos entram com o <b>mesmo código de sala</b>.
    </div>
  </div>

  <!-- CHAT -->
  <div id="chatBox" style="
    position:absolute; right:12px; bottom:12px; width:320px; max-width:44vw;
    background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.12);
    border-radius:12px; backdrop-filter: blur(8px); pointer-events:auto;
    overflow:hidden;">
    <div id="chatLog" style="height:160px; overflow:auto; padding:10px 10px; font-size:13px; line-height:1.25;"></div>
    <div style="display:flex; gap:8px; padding:10px; border-top:1px solid rgba(255,255,255,.10);">
      <input id="chatInput" placeholder="Digite e Enter..."
        style="flex:1; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.16);
        background:rgba(255,255,255,.08); color:#eaf1ff; outline:none;" />
      <button id="chatSend"
        style="border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.08);
        color:#eaf1ff; border-radius:10px; padding:8px 10px; cursor:pointer;">Enviar</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

let QUALITY = "high";
const cfg = {
  // player
  gravity: 22.0,
  jumpVel: 7.2,
  walkSpeed: 4.0,
  runSpeed: 6.6,
  airControl: 0.45,
  friction: 14.0,
  airFriction: 2.2,
  mouseSens: 0.0022,
  maxPitch: 1.50,
  minPitch: -1.45,
  stepHeight: 0.45,
  playerRadius: 0.35,
  playerHeight: 1.72,
  eyeHeight: 1.55,

  // mundo
  worldSize: 320,

  // ruas
  avenueW: 12.0,
  streetW: 8.0,
  sidewalkW: 2.2,
  curbW: 0.22,
  curbH: 0.10,

  // cruzamento maior
  interPad: 0.35,
  interSizeFor: (w)=> w + 2*(2.2 + 0.22) + 2.0,

  // overlap
  overlap: 0.40,
  yAsphalt: 0.012,
  ySidewalk: 0.016,
  yStripe: 0.018,
  yCurb: 0.020,

  // postes
  poleH: 7.8,
  poleSpacing: 18,
  poleInset: 0.65,

  // lotes
  lotFront: 6.0,
  lotDepthBase: 5.2,
  setback: 0.75,
  innerRows: 2,
  rowGap: 5.0,
};

//
// ===== RENDER / SCENE =====
//
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x92bfff);
scene.fog = new THREE.Fog(0x92bfff, 70, 260);

const camera = new THREE.PerspectiveCamera(78, innerWidth/innerHeight, 0.05, 800);

//
// ===== LIGHTING =====
//
scene.add(new THREE.HemisphereLight(0xbad7ff, 0x1a2230, 0.78));
const sun = new THREE.DirectionalLight(0xffffff, 1.15);
sun.position.set(70, 95, 40);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 320;
sun.shadow.camera.left = -140;
sun.shadow.camera.right = 140;
sun.shadow.camera.top = 140;
sun.shadow.camera.bottom = -140;
scene.add(sun);

//
// ===== UI / INPUT =====
//
const btnPlay = document.getElementById("btnPlay");
const btnReset = document.getElementById("btnReset");
const btnQuality = document.getElementById("btnQuality");
const stats = document.getElementById("stats");

const mpName = document.getElementById("mpName");
const mpRoom = document.getElementById("mpRoom");
const btnJoin = document.getElementById("btnJoin");
const mpStatus = document.getElementById("mpStatus");

const chatLog = document.getElementById("chatLog");
const chatInput = document.getElementById("chatInput");
const chatSend = document.getElementById("chatSend");

let pointerLocked = false;
let yaw = 0, pitch = 0;

btnPlay.addEventListener("click", async () => { try { await renderer.domElement.requestPointerLock(); } catch(e){} });
document.addEventListener("pointerlockchange", () => { pointerLocked = (document.pointerLockElement === renderer.domElement); });
document.addEventListener("mousemove", (e) => {
  if (!pointerLocked) return;
  yaw -= e.movementX * cfg.mouseSens;
  pitch -= e.movementY * cfg.mouseSens;
  pitch = Math.max(cfg.minPitch, Math.min(cfg.maxPitch, pitch));
});

const keys = new Set();
addEventListener("keydown", (e)=>{ keys.add(e.code); if (e.code === "Space") e.preventDefault(); });
addEventListener("keyup", (e)=> keys.delete(e.code));

btnReset.addEventListener("click", () => resetPlayer());
btnQuality.addEventListener("click", () => {
  QUALITY = (QUALITY === "high") ? "low" : "high";
  btnQuality.textContent = "Qualidade: " + (QUALITY === "high" ? "Alta" : "Leve");
  applyQuality();
});

function applyQuality(){
  if (QUALITY === "low"){
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.15));
    renderer.shadowMap.enabled = false;
    scene.fog.near = 60; scene.fog.far = 200;
  } else {
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    scene.fog.near = 70; scene.fog.far = 260;
  }
  renderer.setSize(innerWidth, innerHeight);
}

//
// ===== COLLIDERS =====
//
const colliders = [];
function addColliderFromBox(center, size){
  const half = new THREE.Vector3(size.x/2, size.y/2, size.z/2);
  colliders.push({ min: center.clone().sub(half), max: center.clone().add(half) });
}
function addMeshBox(center, size, material, cast=true, receive=true, collider=true){
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), material);
  mesh.position.copy(center);
  mesh.castShadow = cast && QUALITY === "high";
  mesh.receiveShadow = receive && QUALITY === "high";
  scene.add(mesh);
  if (collider) addColliderFromBox(center, size);
  return mesh;
}

//
// ===== MATERIALS =====
//
const mat = {
  ground:   new THREE.MeshStandardMaterial({ color: 0x2c3539, roughness: 0.98 }),
  asphalt:  new THREE.MeshStandardMaterial({ color: 0x1d2226, roughness: 0.96 }),
  sidewalk: new THREE.MeshStandardMaterial({ color: 0x7a8087, roughness: 0.93 }),
  curb:     new THREE.MeshStandardMaterial({ color: 0x9aa2aa, roughness: 0.92 }),
  concrete: new THREE.MeshStandardMaterial({ color: 0x7a7f85, roughness: 0.93 }),
  stripe:   new THREE.MeshStandardMaterial({ color: 0xe7e2b6, roughness: 0.85 }),
  metal:    new THREE.MeshStandardMaterial({ color: 0x6d737a, roughness: 0.65, metalness: 0.35 }),

  plasterA: new THREE.MeshStandardMaterial({ color: 0xc5b8a7, roughness: 0.9 }),
  plasterB: new THREE.MeshStandardMaterial({ color: 0xc9c6bf, roughness: 0.92 }),
  paintBlue:new THREE.MeshStandardMaterial({ color: 0x4b7bd6, roughness: 0.88 }),
  paintGreen:new THREE.MeshStandardMaterial({ color: 0x3aa273, roughness: 0.88 }),
  paintPink:new THREE.MeshStandardMaterial({ color: 0xd46b98, roughness: 0.90 }),
  brick:    new THREE.MeshStandardMaterial({ color: 0x9a5a44, roughness: 0.95 }),
  roofDark: new THREE.MeshStandardMaterial({ color: 0x3e434a, roughness: 0.80, metalness: 0.18 }),
  wood:     new THREE.MeshStandardMaterial({ color: 0x6e4e33, roughness: 0.92 }),
  glass:    new THREE.MeshStandardMaterial({ color: 0x2a4d6b, roughness: 0.25, metalness: 0.05, transparent:true, opacity:0.78 }),
  tankBlue: new THREE.MeshStandardMaterial({ color: 0x2f7fff, roughness: 0.55, metalness: 0.05 }),
  white:    new THREE.MeshStandardMaterial({ color: 0xe6e6e6, roughness: 0.92 }),
};

function pickFavelaWall(r){
  if (r < 0.22) return mat.plasterA;
  if (r < 0.44) return mat.plasterB;
  if (r < 0.62) return mat.paintBlue;
  if (r < 0.78) return mat.paintGreen;
  if (r < 0.92) return mat.paintPink;
  return mat.brick;
}
function lcg(seed){
  seed = (seed * 1664525 + 1013904223) >>> 0;
  return [seed, (seed & 0xffffff) / 0x1000000];
}

//
// ===== BASE WORLD =====
//
(function buildBase(){
  const g = new THREE.PlaneGeometry(cfg.worldSize, cfg.worldSize, 1, 1);
  g.rotateX(-Math.PI/2);
  const ground = new THREE.Mesh(g, mat.ground);
  ground.receiveShadow = QUALITY === "high";
  scene.add(ground);

  const h = 6.0, t = 1.2;
  const half = cfg.worldSize/2;
  addMeshBox(new THREE.Vector3(0, h/2, -half + t/2), new THREE.Vector3(cfg.worldSize, h, t), mat.concrete, false, true);
  addMeshBox(new THREE.Vector3(0, h/2,  half - t/2), new THREE.Vector3(cfg.worldSize, h, t), mat.concrete, false, true);
  addMeshBox(new THREE.Vector3(-half + t/2, h/2, 0), new THREE.Vector3(t, h, cfg.worldSize), mat.concrete, false, true);
  addMeshBox(new THREE.Vector3( half - t/2, h/2, 0), new THREE.Vector3(t, h, cfg.worldSize), mat.concrete, false, true);
})();

function addOrientedPlaneRect(centerX, centerZ, width, length, rotY, material, y){
  const geo = new THREE.PlaneGeometry(width, length);
  geo.rotateX(-Math.PI/2);
  const mesh = new THREE.Mesh(geo, material);
  mesh.position.set(centerX, y, centerZ);
  mesh.rotation.y = rotY;
  mesh.receiveShadow = QUALITY === "high";
  mesh.material.polygonOffset = true;
  mesh.material.polygonOffsetFactor = -1;
  mesh.material.polygonOffsetUnits = -1;
  scene.add(mesh);
  return mesh;
}
function addAxisPlaneRect(x,z,w,d,material,y){
  const geo = new THREE.PlaneGeometry(w,d);
  geo.rotateX(-Math.PI/2);
  const m = new THREE.Mesh(geo, material);
  m.position.set(x,y,z);
  m.receiveShadow = QUALITY === "high";
  m.material.polygonOffset = true;
  m.material.polygonOffsetFactor = -1;
  m.material.polygonOffsetUnits = -1;
  scene.add(m);
  return m;
}
function v2(x,z){ return new THREE.Vector2(x,z); }

//
// ===== ROAD GRAPH =====
//
const nodes = new Map();
const roads = [];
function addNode(id, x, z){ nodes.set(id, { id, p: v2(x,z), roads: new Set() }); }
function addRoad(aId, bId, w, isAvenue=false){
  roads.push({ aId, bId, w, isAvenue });
  nodes.get(aId).roads.add(roads.length-1);
  nodes.get(bId).roads.add(roads.length-1);
}

// blueprint
const GRID_X = [-120, -80, -40, 0, 40, 80, 120];
const GRID_Z = [-120, -80, -40, 0, 40, 80, 120];
(function cityBlueprint(){
  let id=0;
  const idAt={};
  for(let ix=0; ix<GRID_X.length; ix++){
    for(let iz=0; iz<GRID_Z.length; iz++){
      const nid=`n${id++}`;
      idAt[`${ix},${iz}`]=nid;
      addNode(nid, GRID_X[ix], GRID_Z[iz]);
    }
  }
  for(let ix=0; ix<GRID_X.length; ix++){
    for(let iz=0; iz<GRID_Z.length-1; iz++){
      const a=idAt[`${ix},${iz}`], b=idAt[`${ix},${iz+1}`];
      const isAvenue = (GRID_X[ix]===0);
      addRoad(a,b, isAvenue?cfg.avenueW:cfg.streetW, isAvenue);
    }
  }
  for(let iz=0; iz<GRID_Z.length; iz++){
    for(let ix=0; ix<GRID_X.length-1; ix++){
      const a=idAt[`${ix},${iz}`], b=idAt[`${ix+1},${iz}`];
      const isAvenue = (GRID_Z[iz]===0);
      addRoad(a,b, isAvenue?cfg.avenueW:cfg.streetW, isAvenue);
    }
  }
})();

function buildRoadSystem(){
  // cruzamentos
  for(const n of nodes.values()){
    let wMax = cfg.streetW;
    for(const ri of n.roads) wMax = Math.max(wMax, roads[ri].w);
    const s = cfg.interSizeFor(wMax);

    addAxisPlaneRect(n.p.x, n.p.y, s, s, mat.asphalt, cfg.yAsphalt);

    const c = cfg.sidewalkW * 0.82;
    const inset = 0.28;
    const ox = s/2 + c/2 + inset;
    const oz = s/2 + c/2 + inset;

    addAxisPlaneRect(n.p.x - ox, n.p.y - oz, c, c, mat.sidewalk, cfg.ySidewalk);
    addAxisPlaneRect(n.p.x + ox, n.p.y - oz, c, c, mat.sidewalk, cfg.ySidewalk);
    addAxisPlaneRect(n.p.x - ox, n.p.y + oz, c, c, mat.sidewalk, cfg.ySidewalk);
    addAxisPlaneRect(n.p.x + ox, n.p.y + oz, c, c, mat.sidewalk, cfg.ySidewalk);
  }

  // ruas
  for(const r of roads){
    const A = nodes.get(r.aId).p, B = nodes.get(r.bId).p;
    const dx = B.x-A.x, dz=B.y-A.y;
    const len = Math.hypot(dx,dz);
    const ux=dx/len, uz=dz/len;
    const px=-uz, pz=ux;

    const cut = (cfg.interSizeFor(r.w)/2 + cfg.interPad) - cfg.overlap;
    const newLen = Math.max(1, len - cut - cut + cfg.overlap*2);

    const a2 = v2(A.x + ux*cut, A.y + uz*cut);
    const b2 = v2(B.x - ux*cut, B.y - uz*cut);

    const mid = v2((a2.x+b2.x)/2, (a2.y+b2.y)/2);
    const rotY = Math.atan2(dx, dz);

    addOrientedPlaneRect(mid.x, mid.y, r.w, newLen, rotY, mat.asphalt, cfg.yAsphalt);

    if (r.isAvenue){
      addOrientedPlaneRect(mid.x, mid.y, 0.22, newLen*0.92, rotY, mat.stripe, cfg.yStripe);
    }

    const sw = cfg.sidewalkW, curbW=cfg.curbW;

    for (const side of [-1,+1]){
      const offS = side*(r.w/2 + sw/2);
      addOrientedPlaneRect(mid.x + px*offS, mid.y + pz*offS, sw, newLen, rotY, mat.sidewalk, cfg.ySidewalk);

      const curb = new THREE.Mesh(new THREE.BoxGeometry(curbW, cfg.curbH, newLen), mat.curb);
      curb.position.set(
        mid.x + px*(side*(r.w/2 + curbW/2)),
        cfg.curbH/2 + cfg.yCurb,
        mid.y + pz*(side*(r.w/2 + curbW/2))
      );
      curb.rotation.y = rotY;
      curb.receiveShadow = QUALITY === "high";
      scene.add(curb);
    }

    r._trim = { a2, b2, ux, uz, px, pz, newLen, rotY, mid };
  }
}

// ===== POSTES + FIOS =====
function addPole(x,z,h=cfg.poleH){
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.14,h,10), mat.metal);
  pole.position.set(x,h/2,z);
  pole.castShadow = QUALITY === "high";
  pole.receiveShadow = QUALITY === "high";
  scene.add(pole);
  addColliderFromBox(new THREE.Vector3(x,h/2,z), new THREE.Vector3(0.55,h,0.55));
  return pole;
}
function poleTop(p){
  const h = p.geometry.parameters.height;
  return p.position.clone().add(new THREE.Vector3(0, h*0.45, 0));
}
function addCable(a,b,sag=0.95){
  const n=18, pts=[];
  for(let i=0;i<=n;i++){
    const t=i/n;
    const p=new THREE.Vector3().lerpVectors(a,b,t);
    const s = Math.sin(Math.PI*t);
    p.y -= s*sag;
    pts.push(p);
  }
  const geo=new THREE.BufferGeometry().setFromPoints(pts);
  const line=new THREE.Line(geo, new THREE.LineBasicMaterial({color:0x111418}));
  line.frustumCulled=false;
  scene.add(line);
}
function addPolesOnRoad(r, side=+1){
  const t = r._trim;
  const off = side*(r.w/2 + cfg.sidewalkW - cfg.poleInset);

  const a = t.a2, b = t.b2;
  const dx = b.x-a.x, dz=b.y-a.y;
  const len = Math.hypot(dx,dz);
  const n = Math.max(1, Math.floor(len / cfg.poleSpacing));

  const poles=[];
  for(let i=0;i<=n;i++){
    const u=i/n;
    const x = a.x + dx*u + t.px*off;
    const z = a.y + dz*u + t.pz*off;
    poles.push(addPole(x,z, cfg.poleH + (i%3)*0.2));
  }
  for(let i=0;i<poles.length-1;i++){
    addCable(poleTop(poles[i]), poleTop(poles[i+1]), 0.95);
  }
}

// ===== CASA FAVELA =====
function addFavelaHouse(seed, x, z, w, h, d, rotY){
  let r; [seed,r]=lcg(seed);
  const wallMat = pickFavelaWall(r);

  const body = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
  body.position.set(x, h/2, z);
  body.rotation.y = rotY;
  body.castShadow = QUALITY === "high";
  body.receiveShadow = QUALITY === "high";
  scene.add(body);
  addColliderFromBox(new THREE.Vector3(x, h/2, z), new THREE.Vector3(w, h, d));

  const roof = new THREE.Mesh(new THREE.BoxGeometry(w*1.02, 0.18, d*1.02), mat.roofDark);
  roof.position.set(x, h + 0.09, z);
  roof.rotation.y = rotY;
  roof.castShadow = QUALITY === "high";
  roof.receiveShadow = QUALITY === "high";
  scene.add(roof);
  addColliderFromBox(roof.position, new THREE.Vector3(w*1.02, 0.18, d*1.02));

  const band = new THREE.Mesh(new THREE.BoxGeometry(w*1.01, 0.12, d*1.01), mat.white);
  band.position.set(x, Math.min(h-0.25, 1.05), z);
  band.rotation.y = rotY;
  band.castShadow = false;
  band.receiveShadow = QUALITY === "high";
  scene.add(band);

  const frontOffset = d/2 + 0.032;
  const sin = Math.sin(rotY), cos = Math.cos(rotY);
  const fx = x + (0)*cos + (-frontOffset)*sin;
  const fz = z + (0)*sin + (-frontOffset)*cos;

  const doorW = Math.min(0.95, w*0.38);
  const door = new THREE.Mesh(new THREE.BoxGeometry(doorW, 1.75, 0.06), mat.wood);
  door.position.set(fx, 0.88, fz);
  door.rotation.y = rotY;
  door.castShadow = QUALITY === "high";
  scene.add(door);

  const win = new THREE.Mesh(new THREE.BoxGeometry(Math.min(1.0, w*0.35), 0.65, 0.05), mat.glass);
  const win2 = win.clone();

  const wx1 = x + (-(w*0.26))*cos + (-frontOffset)*sin;
  const wz1 = z + (-(w*0.26))*sin + (-frontOffset)*cos;
  win.position.set(wx1, 1.25, wz1);
  win.rotation.y = rotY;

  const wx2 = x + ((w*0.26))*cos + (-frontOffset)*sin;
  const wz2 = z + ((w*0.26))*sin + (-frontOffset)*cos;
  win2.position.set(wx2, 1.25, wz2);
  win2.rotation.y = rotY;

  win.castShadow = false; win.receiveShadow = QUALITY === "high";
  win2.castShadow = false; win2.receiveShadow = QUALITY === "high";
  scene.add(win); scene.add(win2);

  ;[seed,r]=lcg(seed);
  if (r < 0.55){
    const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.55,0.75, 14), mat.tankBlue);
    tank.position.set(x + (Math.random()*0.6-0.3), h + 0.55, z + (Math.random()*0.6-0.3));
    tank.castShadow = QUALITY === "high";
    tank.receiveShadow = QUALITY === "high";
    scene.add(tank);
  }

  return seed;
}

function buildBlocksAndFillLots(){
  let seed = 1337;

  for(let ix=0; ix<GRID_X.length-1; ix++){
    for(let iz=0; iz<GRID_Z.length-1; iz++){
      const xA = GRID_X[ix], xB = GRID_X[ix+1];
      const zA = GRID_Z[iz], zB = GRID_Z[iz+1];

      const midx=(xA+xB)/2, midz=(zA+zB)/2;
      if (Math.abs(midx) < 18 && Math.abs(midz) < 18) continue;

      const leftW  = (xA===0 ? cfg.avenueW : cfg.streetW);
      const rightW = (xB===0 ? cfg.avenueW : cfg.streetW);
      const topW   = (zA===0 ? cfg.avenueW : cfg.streetW);
      const botW   = (zB===0 ? cfg.avenueW : cfg.streetW);

      const extraPad = 0.25;
      const x0 = Math.min(xA,xB) + (leftW/2  + cfg.sidewalkW + extraPad);
      const x1 = Math.max(xA,xB) - (rightW/2 + cfg.sidewalkW + extraPad);
      const z0 = Math.min(zA,zB) + (topW/2   + cfg.sidewalkW + extraPad);
      const z1 = Math.max(zA,zB) - (botW/2   + cfg.sidewalkW + extraPad);

      if ((x1-x0) < 14 || (z1-z0) < 14) continue;

      addAxisPlaneRect((x0+x1)/2, (z0+z1)/2, (x1-x0), (z1-z0), mat.ground, 0.010);

      function fillLine(count, fn){
        for(let i=0;i<count;i++) seed = fn(seed, i, count);
      }

      const lot = cfg.lotFront;

      // Norte
      {
        const span = (x1-x0);
        const count = Math.max(2, Math.floor(span / lot));
        const step = span / count;
        const start = x0 + step/2;

        fillLine(count, (seed,i)=>{
          let r; [seed,r]=lcg(seed);
          const w = 2.8 + r*2.4;
          ;[seed,r]=lcg(seed);
          const d = 3.0 + r*3.0;
          ;[seed,r]=lcg(seed);
          const floors = (r<0.62)?1:(r<0.92?2:3);
          const h = floors*(2.05 + 0.15*Math.random());

          const x = start + i*step + (Math.random()*0.18-0.09);
          const z = (z1 - cfg.setback - d/2) + (Math.random()*0.18-0.09);
          return addFavelaHouse(seed, x, z, w, h, d, 0);
        });
      }

      // Sul
      {
        const span = (x1-x0);
        const count = Math.max(2, Math.floor(span / lot));
        const step = span / count;
        const start = x0 + step/2;

        fillLine(count, (seed,i)=>{
          let r; [seed,r]=lcg(seed);
          const w = 2.8 + r*2.4;
          ;[seed,r]=lcg(seed);
          const d = 3.0 + r*3.0;
          ;[seed,r]=lcg(seed);
          const floors = (r<0.62)?1:(r<0.92?2:3);
          const h = floors*(2.05 + 0.15*Math.random());

          const x = start + i*step + (Math.random()*0.18-0.09);
          const z = (z0 + cfg.setback + d/2) + (Math.random()*0.18-0.09);
          return addFavelaHouse(seed, x, z, w, h, d, Math.PI);
        });
      }

      // Leste
      {
        const span = (z1-z0);
        const count = Math.max(2, Math.floor(span / lot));
        const step = span / count;
        const start = z0 + step/2;

        fillLine(count, (seed,i)=>{
          let r; [seed,r]=lcg(seed);
          const w = 2.8 + r*2.4;
          ;[seed,r]=lcg(seed);
          const d = 3.0 + r*3.0;
          ;[seed,r]=lcg(seed);
          const floors = (r<0.62)?1:(r<0.92?2:3);
          const h = floors*(2.05 + 0.15*Math.random());

          const x = (x1 - cfg.setback - d/2) + (Math.random()*0.18-0.09);
          const z = start + i*step + (Math.random()*0.18-0.09);
          return addFavelaHouse(seed, x, z, w, h, d, -Math.PI/2);
        });
      }

      // Oeste
      {
        const span = (z1-z0);
        const count = Math.max(2, Math.floor(span / lot));
        const step = span / count;
        const start = z0 + step/2;

        fillLine(count, (seed,i)=>{
          let r; [seed,r]=lcg(seed);
          const w = 2.8 + r*2.4;
          ;[seed,r]=lcg(seed);
          const d = 3.0 + r*3.0;
          ;[seed,r]=lcg(seed);
          const floors = (r<0.62)?1:(r<0.92?2:3);
          const h = floors*(2.05 + 0.15*Math.random());

          const x = (x0 + cfg.setback + d/2) + (Math.random()*0.18-0.09);
          const z = start + i*step + (Math.random()*0.18-0.09);
          return addFavelaHouse(seed, x, z, w, h, d, Math.PI/2);
        });
      }

      // internas
      const innerW = (x1-x0), innerD = (z1-z0);
      if (innerW > 26 && innerD > 26){
        for(let row=0; row<cfg.innerRows; row++){
          const inset = 7.0 + row*cfg.rowGap;
          const z = (z0+z1)/2 + (row%2===0 ? inset : -inset);
          const span = (x1-x0) - 6;
          const count = Math.max(3, Math.floor(span / (cfg.lotFront*1.15)));
          const step = span / count;
          const start = (x0+x1)/2 - span/2 + step/2;

          for(let i=0;i<count;i++){
            let r; [seed,r]=lcg(seed);
            const w = 2.6 + r*2.0;
            ;[seed,r]=lcg(seed);
            const d = 2.8 + r*2.4;
            ;[seed,r]=lcg(seed);
            const floors = (r<0.78)?1:(r<0.95?2:3);
            const h = floors*(2.0 + 0.2*Math.random());
            const x = start + i*step + (Math.random()*0.24-0.12);
            seed = addFavelaHouse(seed, x, z + (Math.random()*0.24-0.12), w, h, d, (Math.random()*0.25-0.125));
          }
        }
      }
    }
  }
}

//
// ===== BUILD ALL =====
//
buildRoadSystem();
for (const r of roads){
  if (!r._trim) continue;
  if (r.isAvenue){
    addPolesOnRoad(r, +1);
    addPolesOnRoad(r, -1);
  } else {
    addPolesOnRoad(r, +1);
  }
}
buildBlocksAndFillLots();

// spawn pad
addAxisPlaneRect(18, 18, 16, 16, mat.sidewalk, 0.030);

//
// ===== PLAYER =====
//
const player = { pos: new THREE.Vector3(18, 0.2, 18), vel: new THREE.Vector3(), onGround:false };

function resetPlayer(){ player.pos.set(18,0.2,18); player.vel.set(0,0,0); yaw=0; pitch=0; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function resolveCollisions(){
  const r = cfg.playerRadius;
  const feetY = player.pos.y;
  const headY = player.pos.y + cfg.playerHeight;

  if (player.pos.y < 0){
    player.pos.y = 0;
    if (player.vel.y < 0) player.vel.y = 0;
    player.onGround = true;
  }

  for (const c of colliders){
    if (headY < c.min.y || feetY > c.max.y) continue;

    const closestX = clamp(player.pos.x, c.min.x, c.max.x);
    const closestZ = clamp(player.pos.z, c.min.z, c.max.z);
    const dx = player.pos.x - closestX;
    const dz = player.pos.z - closestZ;
    const dist2 = dx*dx + dz*dz;

    if (dist2 < r*r){
      const dist = Math.sqrt(dist2) || 0.0001;
      const push = (r - dist);
      const nx = dx / dist;
      const nz = dz / dist;

      const top = c.max.y;
      const wantStep = top - feetY;
      if (wantStep > 0 && wantStep <= cfg.stepHeight && player.vel.y <= 0){
        player.pos.y += wantStep + 0.001;
        player.onGround = true;
        continue;
      }

      player.pos.x += nx * push;
      player.pos.z += nz * push;

      const vn = player.vel.x*nx + player.vel.z*nz;
      if (vn < 0){
        player.vel.x -= vn*nx;
        player.vel.z -= vn*nz;
      }
    }
  }
}
function updateGroundState(){
  player.onGround = false;
  if (player.pos.y <= 0.0001){
    player.onGround = true;
    player.pos.y = 0;
    if (player.vel.y < 0) player.vel.y = 0;
  }
}

function getMoveInput(){
  const forward = (keys.has("KeyW") ? 1 : 0) - (keys.has("KeyS") ? 1 : 0);
  const strafe  = (keys.has("KeyD") ? 1 : 0) - (keys.has("KeyA") ? 1 : 0);
  const run = keys.has("ShiftLeft") || keys.has("ShiftRight");
  return { forward, strafe, run };
}

//
// =========================
// MULTIPLAYER + CHAT + SMOOTH
// =========================
const WS_URL = "wss://jogo-rp3-2.onrender.com";

let ws = null;
let myId = null;
let joinedRoom = "";
let joinedName = "";

const remotes = new Map(); // id -> remote object

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (m)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}

function hashColor(str){
  // cor estável por id/nome (HSL)
  let h = 0;
  for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i)) >>> 0;
  const hue = (h % 360);
  return `hsl(${hue}, 80%, 62%)`;
}

function setMpStatus(text, ok=false){
  mpStatus.textContent = text;
  mpStatus.style.color = ok ? "rgba(140,255,170,.95)" : "rgba(255,190,190,.95)";
}

function addChatLine(name, color, text){
  const el = document.createElement("div");
  el.innerHTML = `<span style="color:${color}; font-weight:800;">${escapeHtml(name)}</span>: ${escapeHtml(text)}`;
  chatLog.appendChild(el);
  while (chatLog.childNodes.length > 70) chatLog.removeChild(chatLog.firstChild);
  chatLog.scrollTop = chatLog.scrollHeight;
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function makeNameSprite(name, color){
  // Nome pequeno (não gigante)
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  const W = 256, H = 64;
  canvas.width = W;
  canvas.height = H;

  ctx.clearRect(0,0,W,H);

  ctx.globalAlpha = 0.92;
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  roundRect(ctx, 8, 10, W-16, H-20, 14);
  ctx.fill();

  ctx.globalAlpha = 0.95;
  ctx.strokeStyle = "rgba(255,255,255,0.20)";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.globalAlpha = 1;
  ctx.font = "800 26px system-ui, Segoe UI, Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.strokeText(name, W/2, H/2);

  ctx.fillStyle = color;
  ctx.fillText(name, W/2, H/2);

  const tex = new THREE.CanvasTexture(canvas);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.needsUpdate = true;

  const sm = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite:false });
  const spr = new THREE.Sprite(sm);

  // >>> menor e legível
  spr.scale.set(1.55, 0.38, 1);
  return spr;
}

function ensureRemote(p){
  if (!p?.id || p.id === myId) return null;

  let r = remotes.get(p.id);
  if (r) return r;

  const color = hashColor(p.id);
  const cyl = new THREE.Mesh(
    new THREE.CylinderGeometry(0.35, 0.35, 1.65, 12),
    new THREE.MeshStandardMaterial({ color: new THREE.Color(color) })
  );
  cyl.castShadow = QUALITY === "high";
  cyl.receiveShadow = QUALITY === "high";
  scene.add(cyl);

  const label = makeNameSprite(p.name || "Player", color);
  label.position.set(0, 1.28, 0);
  cyl.add(label);

  r = {
    id: p.id,
    name: p.name || "Player",
    color,
    mesh: cyl,
    label,
    targetPos: new THREE.Vector3(p.x||0, p.y||0, p.z||0),
    renderPos: new THREE.Vector3(p.x||0, p.y||0, p.z||0),
    targetYaw: p.yaw || 0,
    renderYaw: p.yaw || 0
  };
  remotes.set(p.id, r);
  return r;
}

function removeRemote(id){
  const r = remotes.get(id);
  if (!r) return;
  r.mesh.remove(r.label);
  scene.remove(r.mesh);

  r.mesh.geometry.dispose();
  r.mesh.material.dispose();
  if (r.label.material.map) r.label.material.map.dispose();
  r.label.material.dispose();

  remotes.delete(id);
}

function connectWS(){
  if (!joinedRoom) return;
  if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;

  setMpStatus("conectando...", false);
  ws = new WebSocket(WS_URL);

  ws.addEventListener("open", () => {
    setMpStatus("online", true);
    myId = null;
    ws.send(JSON.stringify({ t:"join", room: joinedRoom, name: joinedName }));
  });

  ws.addEventListener("message", (ev)=>{
    let msg;
    try { msg = JSON.parse(ev.data); } catch { return; }

    if (msg.t === "welcome"){
      myId = msg.id;
      addChatLine("Sistema","rgba(255,255,255,.85)",`Você entrou na sala ${joinedRoom}`);
      return;
    }

    if (msg.t === "state" && Array.isArray(msg.players)){
      const alive = new Set();
      for (const p of msg.players){
        if (!p?.id) continue;
        alive.add(p.id);
        const r = ensureRemote(p);
        if (!r) continue;

        // atualiza targets (suavização no tick)
        r.targetPos.set(p.x||0, p.y||0, p.z||0);
        r.targetYaw = p.yaw || 0;

        // se mudou nome, recria label
        const newName = p.name || r.name;
        if (newName !== r.name){
          r.name = newName;
          r.mesh.remove(r.label);
          if (r.label.material.map) r.label.material.map.dispose();
          r.label.material.dispose();
          r.label = makeNameSprite(r.name, r.color);
          r.label.position.set(0,1.28,0);
          r.mesh.add(r.label);
        }
      }
      for (const [id] of remotes){
        if (!alive.has(id)) removeRemote(id);
      }
      return;
    }

    if (msg.t === "left"){
      removeRemote(msg.id);
      return;
    }

    if (msg.t === "chat"){
      const c = hashColor(msg.id || msg.name || "x");
      addChatLine(msg.name || "Player", c, msg.msg || "");
      return;
    }

    if (msg.t === "error"){
      addChatLine("Sistema","rgba(255,190,190,.95)", msg.message || "Erro");
      return;
    }
  });

  ws.addEventListener("close", ()=>{
    setMpStatus("offline", false);
    ws = null; myId = null;
    for (const [id] of remotes) removeRemote(id);
  });

  ws.addEventListener("error", ()=>{
    setMpStatus("erro", false);
  });
}

btnJoin.addEventListener("click", ()=>{
  joinedName = (mpName.value || "Player").trim().slice(0,18) || "Player";
  joinedRoom = (mpRoom.value || "").trim().slice(0,16);
  if (!joinedRoom){
    addChatLine("Sistema","rgba(255,190,190,.95)","Digite um código de sala (ex: favela1)");
    return;
  }
  connectWS();
});

function sendChat(){
  const text = (chatInput.value || "").trim();
  if (!text) return;
  chatInput.value = "";

  if (!ws || ws.readyState !== 1){
    addChatLine("Sistema","rgba(255,190,190,.95)","Você está offline.");
    return;
  }
  ws.send(JSON.stringify({ t:"chat", msg: text }));
}
chatSend.addEventListener("click", sendChat);
chatInput.addEventListener("keydown", (e)=>{ if (e.key === "Enter") sendChat(); });

// tecla T abre chat
addEventListener("keydown", (e)=>{
  if (e.code === "KeyT"){
    e.preventDefault();
    chatInput.focus();
  }
});

//
// ===== LOOP =====
//
let last = performance.now();
let fpsSmooth = 60;

function tick(){
  requestAnimationFrame(tick);
  const now = performance.now();
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  const fps = 1 / Math.max(1e-5, dt);
  fpsSmooth = fpsSmooth*0.92 + fps*0.08;

  camera.rotation.set(pitch, yaw, 0, "YXZ");

  const { forward, strafe, run } = getMoveInput();
  const dir = new THREE.Vector3();
  if (forward !== 0 || strafe !== 0){
    const ang = yaw;
    const fx = Math.sin(ang);
    const fz = Math.cos(ang);
    dir.x = fx*forward + fz*strafe;
    dir.z = fz*forward - fx*strafe;
    dir.normalize();
  }

  const targetSpeed = run ? cfg.runSpeed : cfg.walkSpeed;
  const accel = player.onGround ? 26.0 : (26.0 * cfg.airControl);
  const friction = player.onGround ? cfg.friction : cfg.airFriction;

  player.vel.x += dir.x * targetSpeed * accel * dt;
  player.vel.z += dir.z * targetSpeed * accel * dt;

  const hv = Math.hypot(player.vel.x, player.vel.z);
  if (hv > 0.0001){
    const drop = hv * friction * dt;
    const newHv = Math.max(0, hv - drop);
    const s = newHv / hv;
    player.vel.x *= s;
    player.vel.z *= s;
  }

  player.vel.y -= cfg.gravity * dt;

  if (player.onGround && keys.has("Space")){
    player.vel.y = cfg.jumpVel;
    player.onGround = false;
  }

  player.pos.x += player.vel.x * dt;
  player.pos.y += player.vel.y * dt;
  player.pos.z += player.vel.z * dt;

  const half = cfg.worldSize/2 - 2;
  player.pos.x = clamp(player.pos.x, -half, half);
  player.pos.z = clamp(player.pos.z, -half, half);

  resolveCollisions();
  updateGroundState();

  camera.position.set(player.pos.x, player.pos.y + cfg.eyeHeight, player.pos.z);

  // ===== multiplayer: envia 15x/s (não spamma) =====
  tick._sendAcc = (tick._sendAcc || 0) + dt;
  const SEND_DT = 1/15;

  if (ws && ws.readyState === 1 && myId){
    while (tick._sendAcc >= SEND_DT){
      tick._sendAcc -= SEND_DT;
      ws.send(JSON.stringify({
        t:"me",
        x: player.pos.x,
        y: player.pos.y,
        z: player.pos.z,
        yaw: yaw
      }));
    }
  } else {
    tick._sendAcc = Math.min(tick._sendAcc, SEND_DT);
  }

  // ===== multiplayer: suavização LERP =====
  const posAlpha = 1 - Math.exp(-dt * 12.0);
  const yawAlpha = 1 - Math.exp(-dt * 14.0);

  for (const r of remotes.values()){
    r.renderPos.lerp(r.targetPos, posAlpha);

    let a = r.renderYaw;
    let b = r.targetYaw;
    let d = ((b - a + Math.PI) % (Math.PI*2)) - Math.PI;
    r.renderYaw = a + d * yawAlpha;

    r.mesh.position.set(r.renderPos.x, r.renderPos.y + 0.825, r.renderPos.z);
    r.mesh.rotation.y = r.renderYaw;

    // nome sempre de frente pra câmera
    r.label.quaternion.copy(camera.quaternion);
  }

  stats.innerHTML =
    `<b>Status</b><br>`+
    `FPS: <b>${fpsSmooth.toFixed(0)}</b><br>`+
    `Pos: <span class="muted">${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)}</span><br>`+
    `Chão: <b>${player.onGround ? "sim" : "não"}</b><br>`+
    `Sala: <b>${joinedRoom || "-"}</b> · Jogadores: <b>${(myId ? (remotes.size+1) : 1)}</b>`;

  renderer.render(scene, camera);
}
tick();

addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

applyQuality();
resetPlayer();
setMpStatus("offline", false);

// chat msg inicial
addChatLine("Sistema","rgba(255,255,255,.85)","Dica: aperta T pra abrir o chat. Entre numa sala pra jogar com amigos.");
</script>
</body>
</html>
